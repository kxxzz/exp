(# a 1)
(# b 2)
a b +

(# swap => a b (num) : b a)
(# swap1 => a b : b a)

1 2 swap
(swap "b" 2)
(swap 1 2)
"a" "b" swap1
"c"

(# drop => x :)

(# drop2 drop drop)
(# drop4 drop2 drop2)
(# drop8 drop4 drop4)

drop8

gc

(if (eq 2 (+ 1 3)) 100 200)

(if (eq (+ 1 3) 2) "a" "b")

(# fib => x : (if (gt x 2) (+ (fib (- x 1)) (fib (- x 2))) 1))

20 fib

(fib 20)

(# tailtest
    => n (num) res (num) :
    (if (lt n 0)
        0
        (if (eq n 0)
            1
            (if (eq n 1)
                res
                (tailtest (- n 1) (/ n res))))))

50000 2 tailtest

(tailtest 50000 2)

//drop8

(# dup => x : x x)

[fib] => fib1 :

(fib1 20)

{ 20 fib1 ! }


//(# apply121 => f (num -> num) : f !)

(# apply121 => f ({t} t -> t) : f !)


20 fib1 apply121

=> r :

// dup
// dup
// drop8
// drop4


(& 50) [5 +] map => ary :

gc


(&< ary 45 33)
(&> ary 45)


ary [20 gt] filter => ary1 :

ary size
ary1 size

ary1 [+] reduce

ary

// (# _100doors
//     (# loop => i :
//         (if (le (* i i) 100)
//             (loop (+ i 1))
//             {})))

// _100doors












